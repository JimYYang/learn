#### 数学

---

找很多数的`质因子`

```c++
const int MX = 1e5 + 1;
int omega[MX];
int init = []() {
    for (int i = 2; i < MX; i++)
        if (omega[i] == 0) // i 是质数
            for (int j = i; j < MX; j += i)
                omega[j]++; // i 是 j 的一个质因子
    return 0;
}();


```



---

找很多数的`真因子`（`d < n && n % d == 0`）

```c++
const int MX = 201;
vector<vector<int>> divisors(MX);
int init = [] {
    for (int i = 1; i < MX; i++) {
        for (int j = i * 2; j < MX; j += i) {
            divisors[j].push_back(i);
        }
    }
    return 0;
}();
```

---

#### 满射

[LC205](https://leetcode.cn/problems/isomorphic-strings/description/?envType=study-plan-v2&envId=top-interview-150)

[LC290](https://leetcode.cn/problems/word-pattern/description/?envType=study-plan-v2&envId=top-interview-150)

集合`A`和`B`

若存在`A`到`B`的映射`f`

满足：

1. `f`是`单射`：`a1 != a2 -> f(a1) != f(a2)`

2. `f`是`满射`: `B`中的每个元素都有对应的映射
   1. 另外，还需要证明`f`是一个映射，`A`中的相同元素一定对应`B`中的相等元素 `f(a)`在`B`中对应唯一值



1的证明：开一个`B->A`的哈希表  遍历`A`中的元素`a`  当发现`a`已经被映射过时  则判断`f(b)`是否等于`a`

不等于说明不是单射



2的证明：元素数量一定要相等



3的证明：开一个`A->B`的哈希表  遍历`B`中的元素`b`  当发现`b`已经被映射过时  则判断`f(a)`是否等于`b`

详情见题单代码

