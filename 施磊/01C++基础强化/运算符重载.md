### 运算符重载

---

![image-20231122104049202](/Users/jsyang/Library/Application Support/typora-user-images/image-20231122104049202.png)

---

![image-20231122142225939](/Users/jsyang/Library/Application Support/typora-user-images/image-20231122142225939.png)

这里只能生成临时对象 牺牲效率 不然会出现内存泄漏 


在你的C++代码中，你正在尝试重载`operator+`来连接两个字符串。代码中确实有开辟新内存来存储结果字符串的步骤，但是这种方法可能会引起效率低下，因为涉及到多次构造和析构临时对象。同时，还需要确保正确管理内存以防止泄漏。

一个改进的方法是使用标准库中的`std::string`类，它已经为你处理了这些问题。然而，如果你希望继续使用自己的字符串类，可以考虑以下建议：

1. **使用智能指针（如`std::unique_ptr`或`std::shared_ptr`）**：这可以自动管理内存，当智能指针超出作用域时，它会自动释放其管理的内存。
2. **使用移动语义**：C++11引入了移动构造函数和移动赋值操作符，它们可以避免不必要的复制，从而提高效率。在返回临时对象时，如果你的类支持移动语义，编译器将使用移动构造函数而不是复制构造函数。
3. **避免手动管理内存**：如果可能的话，避免使用裸指针和`new`/`delete`。这样可以减少内存泄漏的风险。如果你必须这样做，请确保每个`new`都有一个相应的`delete`。
4. **返回值优化（RVO）和命名返回值优化（NRVO）**：现代编译器可以优化返回临时对象的代码，以减少或消除临时对象的创建和销毁。编写代码时要利用这一点。**`C++17`强制返回值优化**
5. **使用现有的数据结构和算法**：标准库中有很多工具可以帮助你高效地管理数据。在自己的实现中使用这些工具，可以减少错误和提高效率。

在你的具体情况中，你可以尝试重新设计你的String类来使用移动语义，并且考虑使用智能指针来管理内存。这样，当你创建一个临时String对象并返回它时，移动构造函数会被调用来接管临时对象的内存管理，从而避免了不必要的复制和潜在的内存泄漏。这就要求你的String类要有一个移动构造函数和一个移动赋值操作符。如果你还没有这样做，这是一种提高效率的好方法。

- 优化1 

![image-20231122143751455](/Users/jsyang/Library/Application Support/typora-user-images/image-20231122143751455.png)

可以少一次内存开辟

---

#### 迭代器

迭代器失效

![image-20231122154656306](/Users/jsyang/Library/Application Support/typora-user-images/image-20231122154656306.png)

![image-20231122154541865](/Users/jsyang/Library/Application Support/typora-user-images/image-20231122154541865.png)

需要更新迭代器

![image-20231122154946401](/Users/jsyang/Library/Application Support/typora-user-images/image-20231122154946401.png)

![image-20231122155038027](/Users/jsyang/Library/Application Support/typora-user-images/image-20231122155038027.png)

---

#### `new`和`delete`

`new`指的是`operator new` `delete`指的是`operator delete`

![image-20231122165805474](/Users/jsyang/Library/Application Support/typora-user-images/image-20231122165805474.png)

![image-20231122164623351](/Users/jsyang/Library/Application Support/typora-user-images/image-20231122164623351.png)

对于普通的内置类型  `new`和`delete[]` `new[]`和`delete`可以混用  因为其底层通过`malloc`和`free`实现

但是对于自定义类型 不能混用 因为使用`new[]`开辟内存的时候还多开了存元素个数的内存

![image-20231122165533937](/Users/jsyang/Library/Application Support/typora-user-images/image-20231122165533937.png)

---

`typename`还可以告诉编译器某个名称一定是个类型

比如在类外定义变量  对于模版 在实例化的时候才知道类型  所以需要加上`typename`

![image-20231122225241459](/Users/jsyang/Library/Application Support/typora-user-images/image-20231122225241459.png)