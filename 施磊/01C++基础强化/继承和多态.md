### 继承和多态

---

![image-20231123090952901](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123090952901.png)

![image-20231123091231664](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123091231664.png)

![image-20231123091328739](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123091328739.png)

---

![image-20231123092805703](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123092805703.png)

![image-20231123093109268](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123093109268.png)

---

#### 重载、覆盖和隐藏

![image-20231123094626002](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123094626002.png)

---

#### 基类、派生类的转化

![image-20231123094841121](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123094841121.png)

![image-20231123095211778](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123095211778.png)

![image-20231123095217350](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123095217350.png)

![image-20231123095302722](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123095302722.png)

可以作类型强转  但是不安全

---

### 虚函数、静态和动态绑定

基类还没有定义为虚函数的情况下

![image-20231123100640946](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123100640946.png)

---

#### 类添加虚函数后的影响

![image-20231123101052497](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123101052497.png)

![image-20231123101110387](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123101110387.png)

![image-20231123101215913](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123101215913.png)

重写<=>覆盖

![image-20231123101438134](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123101438134.png)

---

![image-20231123101937007](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123101937007.png)

运行时才能确定调用函数的地址

静态绑定直接call 函数的指令  动态绑定是call寄存器 运行期才能知道

---

![image-20231123102313332](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123102313332.png)

---

![image-20231123102348075](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123102348075.png)

---

![image-20231123102947713](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123102947713.png)

---

#### 多态

![image-20231123142320157](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123142320157.png)

![image-20231123142544623](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123142544623.png)

---

c++构造函数中调用虚函数会发生动态绑定吗？

>在 C++ 中，在构造函数中调用虚函数不会发生动态绑定。这是因为当构造函数执行时，对象的构造过程尚未完成，因此它的动态类型还不是最终类的类型。动态绑定依赖于对象的动态类型，而在构造过程中，对象被视为其基类的实例（如果存在继承），而不是其最终类的实例。
>
>简而言之，在构造函数中调用虚函数将总是调用定义在构造函数所属类（或其父类）中的版本，而不是任何派生类中重写的版本。这是为了防止调用派生类的虚函数，而派生类的部分还没有完全构造，这可能导致未定义的行为或错误。
>
>同样的规则也适用于析构函数：在析构函数中调用虚函数也不会发生动态绑定。在析构时，对象的派生类部分已经被销毁，因此调用的是基类中的虚函数版本。

---

在 C++ 中，动态绑定（多态）只发生在通过指针或引用调用虚函数的情况下。如果直接使用对象本身调用虚函数，不会发生动态绑定，调用的将是该对象类型的函数版本。

这是因为，当使用对象本身进行函数调用时，对象的类型在编译时已经确定，编译器会根据这个静态类型来决定调用哪个函数。而当使用指针或引用时，实际上调用的对象可能是指针或引用所指类型的任何派生类型，这种情况下就需要运行时来确定应该调用哪个函数版本，即动态绑定。

下面是一个示例来说明这一点：

```c++
#include <iostream>

class Base {
public:
    virtual void func() {
        std::cout << "Base function" << std::endl;
    }
};

class Derived : public Base {
public:
    void func() override {
        std::cout << "Derived function" << std::endl;
    }
};

int main() {
    Base b;
    Derived d;

    // 直接调用
    b.func(); // 输出 "Base function"
    d.func(); // 输出 "Derived function"

    // 通过指针调用
    Base* bp = &d;
    bp->func(); // 输出 "Derived function"

    // 通过引用调用
    Base& br = d;
    br.func(); // 输出 "Derived function"
    return 0;
}
```

在这个例子中，当我们使用 `b` 和 `d` 直接调用 `func()` 时，调用的函数版本与对象的静态类型（`Base` 或 `Derived`）匹配。但是当我们通过指针 `bp` 或引用 `br` 调用 `func()` 时，实际上调用的是 `d` 的 `func()` 方法，因为 `bp` 和 `br` 实际上指向 `Derived` 类型的对象，这里发生了动态绑定。

---

```c++
#include <iostream>

class Animal {
public:
	virtual void show() { std::cout << "Animal" << std::endl; }
};
class cat :public Animal {
public:
	void show() { std::cout << "cat" << std::endl; }
};
int main()
{
	cat a;
	Animal& b = a;
    cat& c = a;
	b.show();
    c.show();
}
```

在你提供的C++代码中，我们看到一个基类 `Animal` 和一个派生类 `cat`。在这两个类中，都有一个 `show` 方法。在 `main` 函数中，创建了一个 `cat` 类型的对象 `a`，然后通过引用 `b` 和 `c` 调用 `show` 方法。我们来分析一下这两种调用方式中的动态绑定和静态绑定。

**b c都是动态绑定**

**动态绑定（多态）：**

- 当通过基类的指针或引用调用一个虚函数时，会发生动态绑定。这意味着，运行时会根据对象的实际类型来决定调用哪个版本的函数。
- 在你的代码中，`Animal& b = a;` 这行代码中，`b` 是一个基类 `Animal` 的引用，它实际上引用了一个派生类 `cat` 的对象。因此，当通过 `b.show();` 调用 `show` 方法时，会发生动态绑定。尽管 `b` 的类型是 `Animal&`，但它实际上引用的是 `cat` 对象，所以会调用 `cat` 类中重写的 `show` 方法。

---

![image-20231123152828168](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123152828168.png)

![image-20231123153159585](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123153159585.png)

---

![image-20231123154253623](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123154253623.png)

---

![image-20231123155204909](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123155204909.png)

![image-20231123160317910](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123160317910.png)

![image-20231123160337135](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123160337135.png)

---

基类指针指向基类对象也会发生动态绑定

d是派生类对象

![image-20231123162918075](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123162918075.png)

![image-20231123163958665](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123163958665.png)

![image-20231123164217193](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123164217193.png)

---

#### 经典面试问题

![image-20231123182338655](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123182338655.png)

![image-20231123182352409](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123182352409.png)

输出位`call Derive::show i: 10`

---

![image-20231123182718567](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123182718567.png)

![image-20231123182758501](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123182758501.png)

分清楚哪些事情是编译期做的 哪些是运行期做的

---

注意 如果类包含虚函数  那么对象的前4个字节存放`vfptr` 构造函数左`{` 会把虚函数表写到`vfptr`

![image-20231123183806936](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123183806936.png)

![image-20231123183842744](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123183842744.png)

![image-20231123183701661](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123183701661.png)

![image-20231123183936896](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123183936896.png)

---

#### 虚继承和虚基类

![image-20231123191559707](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123191559707.png)

![image-20231123191436288](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123191436288.png)

![image-20231123191821572](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123191821572.png)

```shell
F:\学习笔记\施磊\1_C++基础精讲\多态\duotai\duotai>cl duotai.cpp /d1reportSingleClassLayoutAnimal
Microsoft (R) C/C++ Optimizing Compiler Version 19.38.33130 for x86
Copyright (C) Microsoft Corporation.  All rights reserved.

duotai.cpp

class Animal    size(4):
        +---
 0      | {vfptr}
        +---

Animal::$vftable@:
        | &Animal_meta
        |  0
 0      | &Animal::show
```

---

### 虚函数和虚继承

![image-20231123192341682](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123192341682.png)

当二者结合到一起的时候  使用多态的调用没有影响 `delete`会出错

![image-20231123192818393](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123192818393.png)

![image-20231123192759403](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123192759403.png)

![image-20231123192944842](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123192944842.png)

这个在`windows vs`下会报错 指针不会自动偏移上去

但是在`linux gcc`下不会报错 指针会自动偏移上去

---

![image-20231123194035682](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123194035682.png)

篮筐代表基类没有虚函数 到了基类才有虚函数

一般情况是基类已经有虚函数  然后派生类直接继承过来 注意  只有一个`vfptr`

`vbtable`存放`vbptr`到上面的偏移量和到基类数据成员的偏移量

![image-20231123194206891](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123194206891.png)

---

#### 多重继承

菱形继承

![image-20231123200745172](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123200745172.png)

会出现A的对象构造两次  析构两次的问题

![image-20231123200723057](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123200723057.png)

解决办法：虚继承

![image-20231123200904825](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123200904825.png)

把虚基类的数据放到后面 原来的地方补上`vbptr`

![image-20231123201047599](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123201047599.png)

需要在`D`中手动添加`A`的构造函数（如果没有默认构造的话）

![image-20231123201353433](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123201353433.png)

---

#### C++的类型转换

![image-20231123203108819](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123203108819.png)

![image-20231123202637970](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123202637970.png)

在指令级别没有区别

但是`const_cast<>`不能改变指针类型  比如`int->char`是不行的

![image-20231123202931673](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123202931673.png)

![image-20231123203204402](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123203204402.png)

![image-20231123203852365](/Users/jsyang/Library/Application Support/typora-user-images/image-20231123203852365.png)