### 智能指针

---

![image-20231128102620190](/Users/jsyang/Library/Application Support/typora-user-images/image-20231128102620190.png)

会造成资源泄露

![image-20231128102821657](/Users/jsyang/Library/Application Support/typora-user-images/image-20231128102821657.png)

![image-20231128103040090](/Users/jsyang/Library/Application Support/typora-user-images/image-20231128103040090.png)

![image-20231128103118072](/Users/jsyang/Library/Application Support/typora-user-images/image-20231128103118072.png)

不会改变引用计数

`weak_ptr`只是观察者 不能使用资源

![image-20231128103209663](/Users/jsyang/Library/Application Support/typora-user-images/image-20231128103209663.png)

![image-20231128103430280](/Users/jsyang/Library/Application Support/typora-user-images/image-20231128103430280.png)

![image-20231128105524922](/Users/jsyang/Library/Application Support/typora-user-images/image-20231128105524922.png)

---

多线程访问共享对象的线程安全问题

![image-20240315135853064](/Users/jsyang/Library/Application Support/typora-user-images/image-20240315135853064.png)

![image-20240315140101409](/Users/jsyang/Library/Application Support/typora-user-images/image-20240315140101409.png)



---

自定义删除器

![image-20240315141033152](/Users/jsyang/Library/Application Support/typora-user-images/image-20240315141033152.png)

![image-20240315141104925](/Users/jsyang/Library/Application Support/typora-user-images/image-20240315141104925.png)

---

make_shared

![image-20240315194856417](/Users/jsyang/Library/Application Support/typora-user-images/image-20240315194856417.png)

![image-20240315194831856](/Users/jsyang/Library/Application Support/typora-user-images/image-20240315194831856.png)



C++中的智能指针，如`std::unique_ptr`和`std::shared_ptr`，提供了自动管理动态分配内存的方式，从而帮助避免内存泄漏。这些智能指针还支持自定义删除器（deleter），允许程序员指定当智能指针销毁时应如何释放其管理的资源。

### 自定义删除器的用途

自定义删除器在以下场景中特别有用：

- 当你需要以特殊的方式释放资源，例如使用特定的释放函数，而不是`delete`或`delete[]`。
- 当管理的资源不是通过`new`或`new[]`分配的，例如通过系统调用或第三方库函数获得的资源。

### `std::unique_ptr`的自定义删除器

`std::unique_ptr`允许在其模板参数中指定删除器类型。删除器可以是函数指针、lambda表达式或任何可调用对象。

```c++
#include <memory>
#include <iostream>

void customDeleter(int* ptr) {
    std::cout << "Custom delete for int pointer\n";
    delete ptr;
}

int main() {
    std::unique_ptr<int, decltype(&customDeleter)> ptr(new int, customDeleter);
    // 使用ptr...
}
```

你也可以使用lambda表达式作为删除器：

```c++
std::unique_ptr<int, void(*)(int*)> ptr(new int, [](int* p) {
    std::cout << "Custom delete for int pointer\n";
    delete p;
});
```

### `std::shared_ptr`的自定义删除器

对于`std::shared_ptr`，删除器可以在构造函数中指定，不需要在模板参数中声明删除器类型。这是因为`std::shared_ptr`使用类型擦除来处理删除器，从而允许在运行时动态指定删除器。

```c++
#include <memory>
#include <iostream>

void customDeleter(int* ptr) {
    std::cout << "Custom delete for int pointer\n";
    delete ptr;
}

int main() {
    std::shared_ptr<int> ptr(new int, customDeleter);
    // 使用ptr...
}
```

### 注意事项

- 自定义删除器不改变智能指针的使用方式，但会改变其如何释放管理的资源。
- 自定义删除器对于`std::unique_ptr`的类型影响更大，因为删除器的类型是`std::unique_ptr`类型的一部分。这意味着拥有不同删除器类型的`std::unique_ptr`彼此不兼容。
- 对于`std::shared_ptr`，由于使用类型擦除技术处理删除器，所以添加自定义删除器不会影响智能指针的类型。

自定义删除器提供了一种灵活的方式来管理非标准或需要特殊处理的资源，使得C++智能指针更加强大和通用。