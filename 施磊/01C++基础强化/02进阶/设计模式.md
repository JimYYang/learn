### 设计模式

---

![image-20231204140623961](/Users/jsyang/Library/Application Support/typora-user-images/image-20231204140623961.png)

---

![image-20231205100454192](/Users/jsyang/Library/Application Support/typora-user-images/image-20231205100454192.png)

---

![image-20231205101227802](/Users/jsyang/Library/Application Support/typora-user-images/image-20231205101227802.png)

---

#### 单例模式

![image-20231205160928091](/Users/jsyang/Library/Application Support/typora-user-images/image-20231205160928091.png)

![image-20231205161021112](/Users/jsyang/Library/Application Support/typora-user-images/image-20231205161021112.png)

![image-20231205161128463](/Users/jsyang/Library/Application Support/typora-user-images/image-20231205161128463.png)

饿汉式一定是线程安全的

懒汉模式把数据成员改为指向对象的指针

![image-20231206082819051](/Users/jsyang/Library/Application Support/typora-user-images/image-20231206082819051.png)

可重入函数：一个函数还没有被执行完  是否会被再调用一次

可重入函数是指能够被多个任务、线程或中断安全地调用的函数。在多线程环境下，可重入函数的概念尤为重要，因为它们保证了在并发执行时函数的行为是安全和可预测的。

### 定义和特性

可重入函数必须满足以下特性：

1. **局部数据隔离**：函数只使用局部变量或者通过其参数传入的数据。它不依赖于或修改共享数据（如全局变量或静态变量），除非这些数据通过互斥机制（如互斥锁）进行了保护。
2. **无状态或有保护的状态**：如果函数必须保持状态信息（例如，静态或全局变量），则这些状态必须被互斥机制保护，以确保并发访问时的一致性和完整性。
3. **可重复调用**：即使在执行过程中被中断，函数也能够保证重新开始执行时的正确性。这意味着函数执行不依赖于调用历史。
4. **不调用非可重入函数**：可重入函数在其执行路径中不能调用任何非可重入的函数。

### 多线程环境下的作用和意义

在多线程环境中，可重入函数的重要性体现在以下几个方面：

1. **线程安全**：在多线程环境中，可重入函数是线程安全的，因为它们不依赖于共享数据或具有适当的同步机制来保护这些数据。这减少了死锁和竞态条件的风险。
2. **并发性能**：可重入函数通常更适合并发执行，因为它们避免了对共享资源的争用，从而提高了程序的并发性能。
3. **可靠性和稳定性**：在中断服务例程或信号处理函数中，可重入函数是必需的，以防止数据损坏和不一致的行为。
4. **模块化和封装**：编写可重入函数鼓励了良好的编程实践，如使用局部变量和参数传递，有助于提高代码的模块化和封装性。

### 应用

在编写多线程应用程序时，使用可重入函数是非常重要的，特别是在处理共享资源或在关键代码段中。选择线程安全的库函数或正确实现自己的可重入函数可以大大减少并发编程中的复杂性和潜在错误。

![image-20231206083059314](/Users/jsyang/Library/Application Support/typora-user-images/image-20231206083059314.png)

不是线程安全的

![image-20231206084324790](/Users/jsyang/Library/Application Support/typora-user-images/image-20231206084324790.png)

![image-20231206084426786](/Users/jsyang/Library/Application Support/typora-user-images/image-20231206084426786.png)

为了防止线程缓存变量

---

另外一种懒汉单例模式

![image-20231206085506716](/Users/jsyang/Library/Application Support/typora-user-images/image-20231206085506716.png)

第一次调用`getInstance`时  构造对象  可能构造过程中另一个线程又调用`getInstance` 线程不安全 但是编译器自动解决了这个问题   

---

在C++中，静态变量的处理可以分为两个阶段：定义和初始化。这两个阶段发生的时间取决于静态变量的类型和上下文。

### 1. 静态变量的定义

静态变量的定义通常发生在编译期。编译器会在编译代码时分配内存空间给静态变量。这个过程包括确定变量的大小和类型，并在程序的数据段中为其分配空间。定义指的是为变量分配存储空间并为其确定位置。

### 2. 静态变量的初始化

静态变量的初始化时机取决于它是局部静态变量还是全局/命名空间作用域的静态变量：

- **全局/命名空间作用域的静态变量**：
  - 这些变量的初始化通常在程序的运行期开始之前就完成了，即在程序的主函数 `main()` 执行之前。
  - 如果初始化表达式是常量表达式，那么这个初始化可能在编译期就完成了（静态初始化）。
  - 如果初始化表达式不是常量表达式，则需要运行期初始化（动态初始化）。
- **局部静态变量**：
  - 局部静态变量的初始化发生在控制流首次通过该变量的定义点时，这显然是在运行期。
  - 每个局部静态变量只被初始化一次，之后即使函数被多次调用，也不会再次初始化该变量。

### 特殊注意点

- C++11及更高版本的C++标准引入了线程安全的局部静态变量初始化。这意味着在多线程环境中，即使多个线程同时第一次访问同一个局部静态变量，该变量的初始化也只会安全地执行一次。
- 对于某些复杂的初始化情况，比如动态初始化的非局部静态变量，可能存在初始化顺序问题，这是因为不同编译单元中静态变量的初始化顺序未定义。

总结来说，静态变量的定义通常在编译期完成，而初始化可能在编译期也可能在运行期进行，这取决于变量的类型和上下文。

----

### 适配器模式

![image-20231206094005743](/Users/jsyang/Library/Application Support/typora-user-images/image-20231206094005743.png)

![image-20231206094357359](/Users/jsyang/Library/Application Support/typora-user-images/image-20231206094357359.png)

---

### 装饰器模式

![image-20231206101612630](/Users/jsyang/Library/Application Support/typora-user-images/image-20231206101612630.png)

![image-20231206101133845](/Users/jsyang/Library/Application Support/typora-user-images/image-20231206101133845.png)

![image-20231206101334750](/Users/jsyang/Library/Application Support/typora-user-images/image-20231206101334750.png)

![image-20231206101448078](/Users/jsyang/Library/Application Support/typora-user-images/image-20231206101448078.png)

![image-20231206102517700](/Users/jsyang/Library/Application Support/typora-user-images/image-20231206102517700.png)

---

![image-20231206220033344](/Users/jsyang/Library/Application Support/typora-user-images/image-20231206220033344.png)

![image-20231206220121238](/Users/jsyang/Library/Application Support/typora-user-images/image-20231206220121238.png)

![image-20231206220244310](/Users/jsyang/Library/Application Support/typora-user-images/image-20231206220244310.png)

![image-20231206220340175](/Users/jsyang/Library/Application Support/typora-user-images/image-20231206220340175.png)

---

![image-20231206222315909](/Users/jsyang/Library/Application Support/typora-user-images/image-20231206222315909.png)

其实就是万能引用

![image-20231206222544651](/Users/jsyang/Library/Application Support/typora-user-images/image-20231206222544651.png)

C++中的完美转发是指能够将函数接收的参数完整无损地转发给另一个函数。这主要通过模板和右值引用实现，尤其是与`std::forward`函数一起使用。完美转发主要用于模板编程中，尤其是在构建通用库和组件时，它允许函数模板保持其接收到的实参类型（包括其值类别：左值或右值）。

以下是一个简单的完美转发的例子：

### 定义一个接收任意参数的函数模板

```
cppCopy code
#include <iostream>
#include <utility>

// 定义一个转发函数，它接收任意类型的参数，并将其转发到另一个函数
template<typename T>
void forwardFunction(T&& arg) {
    // 调用另一个函数，同时保持arg的值类别（左值或右值）
    receiveFunction(std::forward<T>(arg));
}

// 定义接收参数的函数
void receiveFunction(int& x) {
    std::cout << "receiveFunction received an lvalue.\n";
}

void receiveFunction(int&& x) {
    std::cout << "receiveFunction received an rvalue.\n";
}
```

### 使用转发函数

```
cppCopy code
int main() {
    int lvalue = 5;
    forwardFunction(lvalue);  // 转发左值
    forwardFunction(10);      // 转发右值
}
```

在这个例子中，`forwardFunction`是一个函数模板，它接收任意类型的参数。它使用`std::forward`来将接收到的参数转发给`receiveFunction`。由于`std::forward`的使用，`receiveFunction`能够识别传入的参数是左值还是右值，并相应地调用正确的重载版本。

输出将是：

```
Copy code
receiveFunction received an lvalue.
receiveFunction received an rvalue.
```

这表明`forwardFunction`成功地将左值参数作为左值转发，将右值参数作为右值转发。

### 完美转发的重要性

完美转发在模板编程中非常重要，尤其是在构造函数、工厂方法或任何需要将参数转发到其他函数的情况中。它使得函数模板能够保留参数的完整类型信息，包括它们是左值还是右值，这对于保持代码效率和正确性至关重要。



![image-20231206223958061](/Users/jsyang/Library/Application Support/typora-user-images/image-20231206223958061.png)****